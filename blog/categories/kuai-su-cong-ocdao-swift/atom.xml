<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 快速从oc到swift | My World]]></title>
  <link href="http://xiaobenmao.github.io/blog/categories/kuai-su-cong-ocdao-swift/atom.xml" rel="self"/>
  <link href="http://xiaobenmao.github.io/"/>
  <updated>2015-09-08T04:41:57+08:00</updated>
  <id>http://xiaobenmao.github.io/</id>
  <author>
    <name><![CDATA[嗷大喵]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift-闭包]]></title>
    <link href="http://xiaobenmao.github.io/blog/2015/09/01/swift-bi-bao/"/>
    <updated>2015-09-01T09:50:57+08:00</updated>
    <id>http://xiaobenmao.github.io/blog/2015/09/01/swift-bi-bao</id>
    <content type="html"><![CDATA[<p>```
/**</p>

<p>闭包(Closures):
闭包:是自包含的代码块,可以在代码中被传递和使用
闭包可以捕获和存储其所在上下文中任意常量和变量的引用,这就是所谓的闭包并包裹着这些常量和变量,俗称闭包.
闭包的几种形式:
1,“全局函数是一个有名字但不会捕获任何值的闭包
2,嵌套函数是一个有名字并可以捕获其封闭函数域内值的闭包
3,闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包”
闭包的常见优化场景:
1,“利用上下文推断参数和返回值类型
2,隐式返回单表达式闭包，即单表达式闭包可以省略return关键字
3,参数名称缩写
4,尾随（Trailing）闭包语法”
*/</p>

<!--more-->


<pre><code></code></pre>

<p>//: Playground - noun: a place where people can play</p>

<p>import UIKit</p>

<p>var str = &ldquo;Hello, playground&rdquo;</p>

<p>/**
sorted函数
1,接收两个参数:
1>已知类型的数组
2>闭包函数,</p>

<p>*/
// sorted函数
var strs = [&ldquo;dd&rdquo;, &ldquo;cc&rdquo;, &ldquo;aa&rdquo;, &ldquo;bb&rdquo;]</p>

<p>func backwards(str1:String, str2:String)->Bool
{
    return str1 > str2
}</p>

<p>var sortFun = sorted(strs, backwards)</p>

<p>/<em>*
 闭包表达式语法
// 格式
{ (parameters) -> returnType in
    statements
}
1, 函数和返回值都在大括号之内
2, in:该关键字表示闭包的参数和返回值类型定义已经完成,闭包函数体即将开始
</em>/
// 使用
 sortFun = sorted(strs, { (str1:String, str2:String) -> Bool in
    str1 > str2
})</p>

<p>/**
根据上下文推断类型:
    通过内联闭包表达式构造的闭包作为参数传递给函数时,都可以推断出闭包的参数和返回值类型,所以几乎不需要利用完整格式构造任何内联闭包</p>

<p>*/
sortFun = sorted(strs, {str1, str2 in return str1 > str2})</p>

<p>/<em>*
单表达式闭包隐式返回:
    通过隐藏return 关键字来隐式返回单行表达式的结果
</em>/</p>

<p>sortFun = sorted(strs, {s1, s2 in s1 > s2})</p>

<p>/<em>*
参数名称缩写:
    1,内联函数的参数名称可以缩写,使用比如:$0,$1顺序调用闭包参数
    2,如果使用了参数名称缩写,可以省略参数的定义,因为名称缩写的类型会根据函数类型进行推断
    3,in关键字也可以省略,闭包表达式完全由闭包函数体构成
</em>/</p>

<p>sortFun = sorted(strs, {$0 > $1})</p>

<p>/<em>*
运算符函数:
    1,Swift的String类型定义了关于大于号(>)的字符串实现
    2,&ldquo;>"作为一个函数接收两个String类型的参数,并返回Bool类型
</em>/
// 此处刚好满足&rdquo;>&ldquo;运算符的条件
sortFun = sorted(strs, >);</p>

<p>/<em>*
尾随闭包
    使用情况:如果需要将一个很长的闭包表达式作为最后一个参数传递给函数,可以使用尾随闭包来增强函数的可读性
</em>/</p>

<p>// 不使用尾随闭包
func aFunc(closur:()->())
{
    // 函数体部分
}</p>

<p>// 只有一个闭包参数的尾随闭包
aFunc({
    // 闭包主体部分
})</p>

<p>// 有多个参数,且最后一个参数为闭包的的尾随闭包
aFunc(){
    // 闭包主体部分
}</p>

<p>// 如果函数只有闭包表达式一个参数,使用尾随闭包可以省略"()&ldquo;
aFunc{</p>

<p>}</p>

<p>// 字符串数组的sorted排序可以简写
sortFun = sorted(strs){
    $0 > $1
}</p>

<p>/<em>*
Swift的Array类型有一个map方法:
    0,获取一个闭包表达式作为其唯一参数,并返回该元素所映射的值(可以是不同类型的值)
    1,数组中的每一个值都会调用这个闭包
    2,具体的映射方法和返回值类型由闭包来指定
    3,当提供给数组闭包函数后,map方法将返回一个新的数组,数组中包含了与原数组&ndash;对应映射后的值
</em>/</p>

<p>/<em>*
使用map的尾随闭包方法将Int型数组[123, 58, 79]转换为包含对应String类型的数组[&ldquo;OneTwoThree&rdquo;,&ldquo;ThreeFourTwo,"OneTwo&rdquo;&ldquo;]
</em>/</p>

<p>let digitNames = [
    0 : &ldquo;Zero&rdquo;, 1 : &ldquo;Two&rdquo;, 3 : &ldquo;Three&rdquo;,4 : &ldquo;Four&rdquo;,5 : &ldquo;Five&rdquo;,
    6 : &ldquo;Six&rdquo;, 7 : &ldquo;Seven&rdquo;, 8 : &ldquo;Eight&rdquo;,9 : &ldquo;Nine&rdquo;
]</p>

<p>let numbers = [123, 58, 79]</p>

<p>let numbersToStrings = numbers.map{
    (var number)-> String in</p>

<pre><code>var outPut = ""

while(number &gt; 0)
{
    // 个位
    var num1 = number % 10
    outPut += digitNames[num1]!
    number /= 10
}

return outPut
</code></pre>

<p>}</p>

<p>numbersToStrings</p>

<p>/<em>*
闭包表达式(Closure Expressions)
</em>/</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-字符串]]></title>
    <link href="http://xiaobenmao.github.io/blog/2015/09/01/swift-zi-fu-chuan/"/>
    <updated>2015-09-01T09:40:24+08:00</updated>
    <id>http://xiaobenmao.github.io/blog/2015/09/01/swift-zi-fu-chuan</id>
    <content type="html"><![CDATA[<!--more-->


<pre><code class="Swift">
//: Playground - noun: a place where people can play

import UIKit
// 在OC中定义字符串用 @"". Swift中用""
// 注意点: OC中的字符串是NSString, Swift中的字符串是String
//        OC中的字符串是一个对象, 继承于NSObjcte
//        Swift中的字符串是一个结构体
//        Swift中的字符串的性能比OC中的高
var str: String = "wq "

// 拼接
var str2 = "cool"

str += str2

// 格式化
let num = 30
let name = "wq"
// 目标:  name = lnj , age = 30
// 在Swift中可以使用 \()来拼接其它值
var str3 = "name = \(name), age = \(num)"

// 09: 08: 13
// 注意: 所有的值都必须放到数组中, 哪怕只有一个值也需要放到数组中
var str4 = String(format: "%02d: %02d: %02d", arguments: [9, 8, 13])


// 截取
// 注意: 在Swift中, 如果需要截取字符串, 建议使用OC的字符串来截取, 因为Swift中String的字符串截取方法使用起来非常复杂和蛋疼
// Swift中的字符串可以和OC中的字符串非常非常方便的进行转换
var str5: NSString = "wq nb"
var str6 = "wq fc nb" as NSString

var subStr = str5.substringWithRange(NSMakeRange(1, 3))


// Swift中的字符串是支持直接遍历的
var str7 = "www.baidu.com"
for c in str7.characters
{
    print(c)
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-字典]]></title>
    <link href="http://xiaobenmao.github.io/blog/2015/09/01/swift-zi-dian/"/>
    <updated>2015-09-01T09:30:16+08:00</updated>
    <id>http://xiaobenmao.github.io/blog/2015/09/01/swift-zi-dian</id>
    <content type="html"><![CDATA[<!--more-->


<pre><code class="swift">//: Playground - noun: a place where people can play

import UIKit

// 创建字典
// @{@"key": "value"};
// Swift中创建字典和创建数组一样, 用[]
// [String : NSObject] 类型是以后做iOS开发中最常见的一种格式
let dict = ["name": "ls", "age": 30]


// 获取value
dict["name"]

// 遍历字典
for key in dict.keys
{
    print(dict[key])
}

// 利用元祖类型遍历字典, 会自动将字典中的key赋值给元祖中的第一个变量, 将value赋值给元祖中的第二个变量
// 注意: 第一个是key, 第二个value
for (kk, vv) in dict
{
    print(kk)
    print(vv)
}
// 新增key / value
// 如果对应的key在字典中没有, 那么就会新增
var dict2 = ["name": "ls", "age": 30]
dict2["gender"] = "man"
dict2


// 更新key / value
// 如果对应的key在字典中有, 那么就会更新
dict2["name"] = "zs"
dict2

// 删除
dict2.removeValueForKey("name")
dict2

// 更新字典
dict2.updateValue("20", forKey: "age")
dict2

// 合并字典
var dict3 = ["score": 99]

for (key, value) in dict3
{
    dict2[key] = value
}
dict2
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-函数]]></title>
    <link href="http://xiaobenmao.github.io/blog/2015/09/01/swift-han-shu/"/>
    <updated>2015-09-01T09:20:31+08:00</updated>
    <id>http://xiaobenmao.github.io/blog/2015/09/01/swift-han-shu</id>
    <content type="html"><![CDATA[<!--more-->


<pre><code class="Swift">
//: Playground - noun: a place where people can play

import UIKit

/*
Swift定义函数的格式:

语义: 将前面计算的结果返回给  -&gt; 返回值
func 函数名称(参数列表) -&gt; 返回值
{
    执行代码
}
*/

// 没有返回值没有参数
// 如果函数没有返回值, 就写Void
// 如果函数没有返回值还可以简写
// 1. () 替代 Void
// 2. 可以省略 -&gt; ()  -&gt;Void
func say() -&gt; Void
{
    print("hello")
}
say()


func say2() -&gt; ()
{
    print("hello")
}
say2()


func say3()
{
    print("hello")
}
say3()

// 有返回值没有参数

func getNumber() -&gt; Int
{
    return 998
}
print(getNumber())

// 有参数没有返回值

//- (void)sum:(int)a b:(int)b
// Swift2.0中, 会自动将形参列表中的第二个参数开始的参数名称作为便签, 以便于提高阅读性
// Swift2.0之前, 不会这样
func sum(a: Int, b: Int)
{
    print(a + b)
}
sum(10, b: 20)


// 添加标签, 添加外部参数
// x/y称之为外部参数, a/b称之为内部参数
func sum2(x a: Int,y b: Int)
{
    print(a + b)
}
sum2(x: 10, y: 20)

// Swift2.0之前的写法, 只要加上#那么a/b既是外部参数, 也是内部参数
//func sum2(#a: Int,#b: Int)
//{
//    print(a + b)
//}
//sum2(a: 10, b: 20)

// 有参数有返回值
func sum4(a: Int, b: Int) -&gt; Int
{
    return a + b
}
print(sum4(10, b: 30))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift-数组]]></title>
    <link href="http://xiaobenmao.github.io/blog/2015/09/01/swift-shu-zu/"/>
    <updated>2015-09-01T08:44:08+08:00</updated>
    <id>http://xiaobenmao.github.io/blog/2015/09/01/swift-shu-zu</id>
    <content type="html"><![CDATA[<h1>数组</h1>

<h2>简单体验</h2>

<pre><code class="swift">let arr = ["zhangsan", "lisi"]
print(arr)

// 遍历每一个元素
for a in arr {
    print(a)
}

// 像 OC 一样打印
print(arr as NSArray)
</code></pre>

<!--more-->


<h2>数组中保存的对象类型</h2>

<pre><code class="swift">// 数组中保存的都是字符串
let arr = ["zhangsan", "lisi"]

// 数组中保存的是 NSObject
let arr1 = ["zhangsan", 1]
</code></pre>

<ul>
<li>阶段性小结

<ul>
<li>数组使用 [] 定义，这一点与 OC 相同</li>
<li>如果初始化时，所有内容类型一致，则数组中保存的是该类型的内容</li>
<li>如果初始化时，所有内容类型不一致，则数组中保存的是 <code>NSObject</code></li>
</ul>
</li>
</ul>


<h2>常见数组操作</h2>

<pre><code class="swift">// 定义只能保存字符串类型数组
var array: [String]

// 初始化数组
array = ["zhangsan"]

// 添加元素
array.append("lisi")

print(array)

// 删除元素
array.removeAtIndex(1)
print(array)

// 删除所有元素
// 删除所有, 如果传入true代表删除之后需要保持数组现有的容量, 如果传入false代表不保持当前容量
array.removeAll(keepCapacity: true)
print(array.capacity)

/**
1,注意数组容量的变化
    1&gt;如果数组容量不够,则在当前基础上乘2
    2&gt;如果容量足够,继续添加数据,不足则重复那步骤:1&gt;
*/
for i in 0..&lt;10 {
    array.append("\(i)")
    print("\(array) --- \(array.capacity)")
}

/**
 实例化新的数组
 1,Swift中, 如果一个变量没有初始化是不能被使用的
 2, [[xx alloc]initWithXXX:]  &lt;==&gt;  (XXX:)
      [[XX alloc]init] &lt;==&gt; ()
 */ 

var array2 = [String]()
array2.append("1")

var array3:[String] = ["a","b"]
array3.append("2")

// 拼接数组
// 注意点: 只有相同类型的数组才能进行合并
// Swift是强语言, 不同数据类型不能进行运算
array += array2

print(array)

// 打印数组的长度
array2.count
</code></pre>

<ul>
<li>阶段性小结

<ul>
<li>如果定义数组时指定了保存对象的类型，择不能向数组中添加其他类型的内容</li>
<li>可以使用 <code>[String]()</code></li>
<li><code>let</code> 定义的数组是<code>不可变的</code></li>
<li><code>var</code> 定义的数组是<code>可变的</code></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
